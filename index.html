<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Trivial Kids ES ‚Äî Tablero</title>
  <meta name="description" content="Trivial con tablero, quesitos y bancos de preguntas por JSON. Tema claro/oscuro y aleatorizaci√≥n de preguntas/opciones." />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel para usar JSX en un solo archivo -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body, #root { height: 100%; }
    .cell { transition: transform .08s ease; }
    .cell:hover { transform: translateY(-2px) scale(1.01); }
    .die { width: 48px; height: 48px; border-radius: 12px; display:flex; align-items:center; justify-content:center; font-weight:800; }
    .dot { width: 12px; height: 12px; border-radius: 9999px; display:inline-block; margin-right:6px; }
    .token { width: 18px; height: 18px; border-radius: 9999px; border:2px solid #0f172a; box-shadow: 0 1px 0 rgba(0,0,0,.25); }
  </style>
</head>
<body class="min-h-screen">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useEffect, useMemo, useRef, useState } = React;

    // ====== Persistencia simple ======
    const STORAGE = {
      setup: 'tk_tablero_setup_v2',
      theme: 'tk_theme_v2',
      answered: 'tk_answered_ids_v2'
    };

    function useLocalStorage(key, initial){
      const [state, setState] = React.useState(()=>{
        try{ const raw = localStorage.getItem(key); return raw? JSON.parse(raw): initial; }catch{ return initial; }
      });
      React.useEffect(()=>{ try{ localStorage.setItem(key, JSON.stringify(state)); }catch{} },[key,state]);
      return [state,setState];
    }

    // ====== Tema claro/oscuro ======
    const ThemeToggle = ({theme,setTheme})=>{
      return (
        <button onClick={()=>setTheme(theme==='dark'?'light':'dark')}
          className="px-3 py-1.5 rounded-xl border text-sm bg-slate-100 dark:bg-slate-800 border-slate-300 dark:border-slate-600">
          {theme==='dark'? 'üåô Modo oscuro' : '‚òÄÔ∏è Modo claro'}
        </button>
      );
    };

    const CAT_STYLES = (dark)=>({
      GEO:{name:'Geograf√≠a', cls: dark? 'bg-sky-900 text-sky-200 border border-sky-700':'bg-sky-100 text-sky-800 border border-sky-300'},
      HIS:{name:'Historia', cls: dark? 'bg-amber-900 text-amber-200 border border-amber-700':'bg-amber-100 text-amber-800 border border-amber-300'},
      LEN:{name:'Lengua', cls: dark? 'bg-rose-900 text-rose-200 border border-rose-700':'bg-rose-100 text-rose-800 border border-rose-300'},
      SCI:{name:'Ciencia', cls: dark? 'bg-emerald-900 text-emerald-200 border border-emerald-700':'bg-emerald-100 text-emerald-800 border border-emerald-300'},
      CUL:{name:'Cultura/Deporte', cls: dark? 'bg-violet-900 text-violet-200 border border-violet-700':'bg-violet-100 text-violet-800 border border-violet-300'},
      LANG:{name:'Idiomas (EN/FR)', cls: dark? 'bg-yellow-900 text-yellow-200 border border-yellow-700':'bg-yellow-100 text-yellow-800 border border-yellow-300'},
      RIDDLE:{name:'Adivinanzas', cls: dark? 'bg-orange-900 text-orange-200 border border-orange-700':'bg-orange-100 text-orange-800 border border-orange-300'},
      MEDIA:{name:'Pel√≠culas/Juegos', cls: dark? 'bg-indigo-900 text-indigo-200 border border-indigo-700':'bg-indigo-100 text-indigo-800 border border-indigo-300'},
      REL:{name:'Religi√≥n', cls: dark? 'bg-teal-900 text-teal-200 border border-teal-700':'bg-teal-100 text-teal-800 border border-teal-300'},
      MUS:{name:'M√∫sica', cls: dark? 'bg-fuchsia-900 text-fuchsia-200 border border-fuchsia-700':'bg-fuchsia-100 text-fuchsia-800 border border-fuchsia-300'}
    });

    const DIFF_STYLES = (dark)=>({
      EASY:{label:'F√°cil', cls: dark? 'bg-emerald-900 text-emerald-200 border border-emerald-700':'bg-emerald-100 text-emerald-800 border border-emerald-300'},
      MEDIUM:{label:'Media', cls: dark? 'bg-sky-900 text-sky-200 border border-sky-700':'bg-sky-100 text-sky-800 border border-sky-300'},
      HARD:{label:'Dif√≠cil', cls: dark? 'bg-orange-900 text-orange-200 border border-orange-700':'bg-orange-100 text-orange-800 border border-orange-300'},
      EXPERT:{label:'Muy dif√≠cil', cls: dark? 'bg-rose-900 text-rose-200 border border-rose-700':'bg-rose-100 text-rose-800 border border-rose-300'}
    });

    // ====== Aleatoriedad con semilla (para barajar preguntas y opciones) ======
    function rng(seed){ let s = seed>>>0; return ()=>{ s = (s*1664525+1013904223)>>>0; return s/0x100000000; }; }
    function shuffleWithSeed(arr, seed){ const a=[...arr]; const R=rng(seed); for(let i=a.length-1;i>0;i--){ const j=Math.floor(R()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    // ====== Carga de preguntas desde manifest ======
    async function loadAllQuestions() {
      // Cargamos manifest y luego cada pack
      const mf = await fetch('questions/manifest.json').then(r=>r.json());
      const files = (mf && mf.files) || [];
      const datas = await Promise.all(files.map(p=>fetch(p).then(r=>r.json()).catch(()=>null)));
      let list = [];
      datas.forEach(d=>{ if(d && Array.isArray(d.questions)) list = list.concat(d.questions); });
      // saneado m√≠nimo
      list = list.filter(q => q && q.q && Array.isArray(q.options) && q.options.length===4 && typeof q.correct==='number');
      return list;
    }

    // ====== Tablero (24 casillas alrededor) ======
    // Generamos un anillo 5x5 sin centro, con 24 celdas. Algunas son "quesito".
    function buildBoard(activeCats){
      // repetimos categor√≠as alrededor del anillo
      const cats = activeCats.length? activeCats: ['GEO','HIS','LEN','SCI','CUL','LANG','RIDDLE','MEDIA','REL','MUS'];
      const ringIdx = [
        [0,0],[1,0],[2,0],[3,0],[4,0],
        [4,1],[4,2],[4,3],[4,4],
        [3,4],[2,4],[1,4],[0,4],
        [0,3],[0,2],[0,1]
      ];
      // A√±adimos tambi√©n intermedias para tener 24
      const extra = [[2,1],[3,1],[3,2],[2,3],[1,3],[1,2],[1,1],[2,2],[3,3]]; // 9 m√°s => 25, quitamos centro (2,2)
      const ring = [...ringIdx, ...extra.filter(p=>!(p[0]===2 && p[1]===2))].slice(0,24);
      const cells = ring.map((pos, i)=>{
        const cat = cats[i % cats.length];
        const wedge = (i % Math.floor(24/Math.min(cats.length,6))===0); // cada cierto n√∫mero marcamos quesito
        return { i, pos, cat, wedge };
      });
      return cells;
    }

    // ====== App ======
    function App(){
      const [theme,setTheme] = useLocalStorage(STORAGE.theme,'light');
      useEffect(()=>{ document.documentElement.classList.toggle('dark', theme==='dark'); },[theme]);

      const [setup,setSetup] = useLocalStorage(STORAGE.setup,{
        players: ['Jugador 1','Jugador 2','',''],
        playerCount: 2,
        categories: { GEO:true,HIS:true,LEN:true,SCI:true,CUL:true,LANG:true,RIDDLE:true,MEDIA:true,REL:true,MUS:true },
        difficulties: { EASY:true, MEDIUM:true, HARD:true, EXPERT:true },
        onlyNew: false
      });

      const activeCats = useMemo(()=> Object.entries(setup.categories).filter(([,v])=>v).map(([k])=>k), [setup]);
      const [allQuestions,setAllQuestions] = useState([]);
      const [loading,setLoading] = useState(true);
      const [error,setError] = useState('');

      // answered ids para evitar repetir si solo nuevas
      const [answered,setAnswered] = useLocalStorage(STORAGE.answered,[]);

      useEffect(()=>{ (async()=>{
        try{ setLoading(true); const q = await loadAllQuestions(); setAllQuestions(q); }
        catch(e){ setError('No se pudieron cargar preguntas.'); }
        finally{ setLoading(false); }
      })(); },[]);

      // Estado de partida con tablero
      const [game,setGame] = useState(null); // {seed, board, deckByCat, players:[{name,pos,wedges:Set}], turn, rolling:boolean, lastRoll}

      function startGame(){
        const seed = Date.now();
        // pool filtrado por categor√≠as y dificultad
        const diffs = Object.entries(setup.difficulties).filter(([,v])=>v).map(([k])=>k);
        let pool = allQuestions.filter(q => activeCats.includes(q.cat) && diffs.includes(q.diff));
        if(setup.onlyNew){ pool = pool.filter(q=>!answered.includes(q.id)); }
        // Mezclamos preguntas y tambi√©n sus opciones
        const poolShuffled = shuffleWithSeed(pool, seed);
        const withOpt = poolShuffled.map((q,idx)=>{
          const idxs=[0,1,2,3];
          const order = shuffleWithSeed(idxs, seed+idx+q.q.length);
          const options = order.map(i=>q.options[i]);
          const correct = order.indexOf(q.correct);
          return {...q, options, correct};
        });
        // Agrupar por categor√≠a para facilitar extracci√≥n
        const deckByCat = {};
        activeCats.forEach(c=> deckByCat[c] = []);
        withOpt.forEach(q=>{ if(deckByCat[q.cat]) deckByCat[q.cat].push(q); });
        // Construir tablero
        const board = buildBoard(activeCats);
        // Jugadores
        const players = Array.from({length: setup.playerCount}).map((_,i)=>({
          name: setup.players[i] || `Jugador ${i+1}`,
          pos: 0,
          wedges: {}, // cat -> true
        }));
        setGame({ seed, board, deckByCat, players, turn:0, rolling:false, lastRoll:null, state:'idle' });
      }

      function nextTurn(correct){
        setGame(g=>{
          if(!g) return g;
          // Si acierta, repite turno; si falla, pasa al siguiente
          if(correct) return { ...g, state:'idle' };
          const next = (g.turn+1)%g.players.length;
          return { ...g, turn: next, state:'idle' };
        });
      }

      function rollDie(){
        setGame(g=> !g? g : { ...g, rolling:true });
        setTimeout(()=>{
          setGame(g=>{
            if(!g) return g;
            const n = Math.floor(Math.random()*6)+1;
            // mover jugador actual
            const p = [...g.players];
            const me = { ...p[g.turn] };
            me.pos = (me.pos + n) % g.board.length;
            p[g.turn] = me;
            return { ...g, players: p, rolling:false, lastRoll:n, state:'landed' };
          });
        }, 350);
      }

      function askQuestionFor(cat){
        setGame(g=>{
          if(!g) return g;
          const pile = g.deckByCat[cat]||[];
          if(pile.length===0){
            alert('Sin preguntas disponibles para esta categor√≠a con los filtros actuales.');
            return { ...g, state:'idle' };
          }
          const q = pile.shift(); // saca una
          return { ...g, deckByCat:{...g.deckByCat,[cat]:pile}, currentQ:q, state:'asking' };
        });
      }

      function answer(idx){
        setGame(g=>{
          if(!g) return g;
          const q = g.currentQ; if(!q) return g;
          const isCorrect = (idx===q.correct);
          // Guardar id como respondida
          try{ if(!answered.includes(q.id)){ setAnswered([...answered,q.id]); } }catch{}
          // Si es casilla de quesito y acierta -> a√±ade wedge
          const cell = g.board[g.players[g.turn].pos];
          const p = [...g.players];
          const me = { ...p[g.turn] };
          if(isCorrect){
            if(cell.wedge){ me.wedges = { ...me.wedges, [cell.cat]: true }; }
          }
          p[g.turn] = me;
          const win = Object.keys(me.wedges).length >= activeCats.length;
          if(win){
            return { ...g, players:p, currentQ:null, state:'win' };
          }
          return { ...g, players:p, currentQ:null, state:'feedback', lastCorrect:isCorrect };
        });
      }

      // UI helpers
      const dark = theme==='dark';
      const catMeta = CAT_STYLES(dark);
      const diffMeta = DIFF_STYLES(dark);

      return (
        <div className={"min-h-screen "+(dark? 'bg-slate-950 text-slate-100':'bg-gradient-to-b from-white to-slate-50 text-slate-800')}>
          <div className="max-w-6xl mx-auto px-4 py-5">
            <header className="flex items-center justify-between gap-2">
              <h1 className="text-2xl sm:text-3xl font-extrabold">Trivial Kids ES ‚Äî Tablero</h1>
              <div className="flex items-center gap-2">
                <ThemeToggle theme={theme} setTheme={setTheme} />
                <button onClick={()=>setGame(null)} className="px-3 py-1.5 rounded-xl border bg-slate-100 dark:bg-slate-800 border-slate-300 dark:border-slate-600 text-sm">Nueva partida</button>
              </div>
            </header>

            {loading && <div className="mt-6 p-4 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700">Cargando banco de preguntas‚Ä¶</div>}
            {error && <div className="mt-6 p-4 rounded-2xl border bg-rose-100 text-rose-800 border-rose-300">{error}</div>}

            {!game ? (
              <Setup all={allQuestions} setup={setup} setSetup={setSetup} startGame={startGame} catMeta={catMeta} diffMeta={diffMeta} />
            ) : (
              <BoardUI game={game} setGame={setGame} catMeta={catMeta} diffMeta={diffMeta} rollDie={rollDie} askQuestionFor={askQuestionFor} answer={answer} nextTurn={nextTurn} />
            )}

            <footer className="mt-8 text-center text-xs text-slate-500">Este modo usa tus packs desde <code>questions/manifest.json</code>. Las opciones de respuesta est√°n <b>barajadas</b> en cada pregunta y el <b>orden del mazo</b> cambia cada partida.</footer>
          </div>
        </div>
      );
    }

    function Setup({all, setup, setSetup, startGame, catMeta, diffMeta}){
      const available = useMemo(()=>{
        const cats = Object.entries(setup.categories).filter(([,v])=>v).map(([k])=>k);
        const diffs = Object.entries(setup.difficulties).filter(([,v])=>v).map(([k])=>k);
        return all.filter(q=>cats.includes(q.cat)&&diffs.includes(q.diff)).length;
      },[all,setup]);

      return (
        <div className="mt-6 grid lg:grid-cols-2 gap-6">
          <section className="p-4 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700">
            <h2 className="font-bold mb-3">Configuraci√≥n</h2>
            <div className="grid sm:grid-cols-2 gap-4">
              <div>
                <label className="text-sm">Jugadores</label>
                <div className="mt-2 flex gap-2">
                  {[1,2,3,4].map(n=> (
                    <button key={n} onClick={()=>setSetup({...setup,playerCount:n})}
                      className={(setup.playerCount===n? 'bg-slate-900 text-white dark:bg-white dark:text-slate-900':'bg-slate-100 dark:bg-slate-800 text-slate-800 dark:text-slate-100')+" px-3 py-1.5 rounded-xl border border-slate-300 dark:border-slate-600"}>{n}</button>
                  ))}
                </div>
              </div>
              <div>
                <label className="text-sm">Nombres</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                  {Array.from({length: setup.playerCount}).map((_,i)=> (
                    <input key={i} value={setup.players[i]}
                      onChange={e=>{ const p=[...setup.players]; p[i]=e.target.value; setSetup({...setup, players:p}); }}
                      className="px-3 py-2 rounded-xl border bg-slate-50 dark:bg-slate-800 border-slate-300 dark:border-slate-600"/>
                  ))}
                </div>
              </div>
              <div className="sm:col-span-2">
                <label className="text-sm">Categor√≠as</label>
                <div className="mt-2 flex flex-wrap gap-2">
                  {Object.keys(catMeta).map(k=> (
                    <button key={k} onClick={()=>setSetup({...setup, categories:{...setup.categories, [k]: !setup.categories[k]}})}
                      className={(setup.categories[k]? catMeta[k].cls : 'bg-slate-100 dark:bg-slate-800 text-slate-500 border border-slate-300 dark:border-slate-600')+" px-3 py-1.5 rounded-xl text-sm"}>{catMeta[k].name}</button>
                  ))}
                </div>
              </div>
              <div className="sm:col-span-2">
                <label className="text-sm">Dificultad</label>
                <div className="mt-2 flex flex-wrap gap-2">
                  {Object.entries(diffMeta).map(([k,v])=> (
                    <button key={k} onClick={()=>setSetup({...setup, difficulties:{...setup.difficulties, [k]: !setup.difficulties[k]}})}
                      className={(setup.difficulties[k]? v.cls : 'bg-slate-100 dark:bg-slate-800 text-slate-500 border border-slate-300 dark:border-slate-600')+" px-3 py-1.5 rounded-xl text-sm"}>{v.label}</button>
                  ))}
                </div>
              </div>
              <div>
                <label className="text-sm">Modo de selecci√≥n</label>
                <div className="mt-2 flex items-center gap-2 text-sm">
                  <input id="onlyNew" type="checkbox" checked={setup.onlyNew} onChange={e=>setSetup({...setup, onlyNew:e.target.checked})} />
                  <label htmlFor="onlyNew">Usar solo preguntas nuevas (no respondidas)</label>
                </div>
                <div className="mt-2 text-xs text-slate-500">Disponibles con filtros: {available}</div>
              </div>
            </div>
            <div className="mt-4 flex justify-end">
              <button disabled={available===0} onClick={startGame}
                className={(available>0? 'bg-emerald-600 hover:bg-emerald-700':'bg-slate-300')+" text-white px-4 py-2 rounded-2xl font-semibold"}>¬°Empezar!</button>
            </div>
          </section>

          <section className="p-4 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700">
            <h2 className="font-bold mb-3">C√≥mo se juega (modo tablero)</h2>
            <ul className="list-disc pl-5 text-sm space-y-1">
              <li>Tira el dado y avanza por el anillo del tablero.</li>
              <li>Al caer en una casilla, responde una pregunta de esa categor√≠a.</li>
              <li>Si la casilla es de <b>quesito</b> y aciertas, ganas el quesito de esa categor√≠a.</li>
              <li>Si aciertas, repites turno; si fallas, pasa al siguiente jugador.</li>
              <li>Gana quien consigue todos los quesitos de las categor√≠as activas.</li>
            </ul>
          </section>
        </div>
      );
    }

    function BoardUI({game,setGame,catMeta,diffMeta,rollDie,askQuestionFor,answer,nextTurn}){
      const activeCatsOrdered = Array.from(new Set(game.board.map(c=>c.cat)));
      const cellsByPos = {};
      game.board.forEach(c=>{ cellsByPos[c.pos.join(',')] = c; });

      const currentPlayer = game.players[game.turn];
      const cell = game.board[currentPlayer.pos];

      useEffect(()=>{
        if(game.state==='landed'){
          askQuestionFor(cell.cat);
        }
      },[game.state]);

      return (
        <div className="mt-6 grid lg:grid-cols-2 gap-6">
          <section className="p-4 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700">
            <h3 className="font-bold mb-3">Tablero</h3>
            <div className="grid grid-cols-5 gap-2">
              {Array.from({length:5}).map((_,y)=> (
                <React.Fragment key={y}>
                  {Array.from({length:5}).map((_,x)=>{
                    const key = `${x},${y}`;
                    const c = cellsByPos[key];
                    const isRing = !!c;
                    const isHere = (game.players.some(p=> game.board[p.pos].pos[0]===x && game.board[p.pos].pos[1]===y));
                    return (
                      <div key={x} className={(isRing? (c.wedge? 'bg-slate-200 dark:bg-slate-800':'bg-slate-100 dark:bg-slate-900'):'bg-transparent')+" cell aspect-square rounded-xl border " + (isRing? 'border-slate-300 dark:border-slate-700':'border-transparent')+" relative overflow-hidden"}>
                        {isRing && (
                          <div className={catMeta[c.cat].cls+" absolute left-1 top-1 rounded-md text-[10px] px-1.5 py-0.5"}>{c.wedge? 'Quesito' : catMeta[c.cat].name}</div>
                        )}
                        {isHere && (
                          <div className="absolute right-1.5 bottom-1.5 flex gap-1">
                            {game.players.map((p,i)=>{
                              const pos = game.board[p.pos].pos;
                              if(pos[0]!==x||pos[1]!==y) return null;
                              const colors=['bg-rose-500','bg-sky-500','bg-emerald-500','bg-amber-500'];
                              return <div key={i} className={"token "+colors[i]} title={p.name}></div>
                            })}
                          </div>
                        )}
                      </div>
                    );
                  })}
                </React.Fragment>
              ))}
            </div>

            <div className="mt-3 flex items-center gap-3">
              <div className="die bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-600">{game.lastRoll||'‚Äì'}</div>
              <button disabled={game.rolling || game.state==='asking'} onClick={rollDie}
                className={(game.rolling? 'bg-slate-300':'bg-slate-900 dark:bg-white text-white dark:text-slate-900 hover:opacity-90')+" px-4 py-2 rounded-2xl font-semibold"}>Tirar dado</button>
              <div className="text-sm text-slate-600 dark:text-slate-400">Turno: <b>{game.players[game.turn].name}</b></div>
            </div>
          </section>

          <section className="p-4 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700">
            <h3 className="font-bold mb-3">Marcador y quesitos</h3>
            <div className="grid gap-3">
              {game.players.map((p,i)=> (
                <div key={i} className={(i===game.turn?'ring-2 ring-slate-900 dark:ring-white':'')+" rounded-xl p-3 bg-slate-50 dark:bg-slate-800 border border-slate-200 dark:border-slate-700"}>
                  <div className="text-sm font-semibold mb-2">{p.name}</div>
                  <div className="flex flex-wrap gap-2">
                    {activeCatsOrdered.map(cat=> (
                      <div key={cat} className={(p.wedges[cat]? catMeta[cat].cls: 'bg-slate-100 dark:bg-slate-700 text-slate-500 border border-slate-300 dark:border-slate-600')+" px-2 py-1 rounded-md text-xs"}>
                        {catMeta[cat].name}
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </section>

          {game.state==='asking' && (
            <QuestionModal q={game.currentQ} catMeta={catMeta} answer={answer} />
          )}

          {game.state==='feedback' && (
            <Feedback correct={game.lastCorrect} onNext={()=>nextTurn(game.lastCorrect)} />
          )}

          {game.state==='win' && (
            <Win name={game.players[game.turn].name} />
          )}
        </div>
      );
    }

    const QuestionModal = ({q, catMeta, answer})=>{
      return (
        <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50">
          <div className="w-[min(680px,92vw)] p-4 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700 shadow-xl">
            <div className="flex items-center justify-between">
              <span className={catMeta[q.cat].cls+" px-2 py-1 rounded-md text-xs"}>{catMeta[q.cat].name}</span>
              <span className="text-xs text-slate-500">Respuestas aleatorias</span>
            </div>
            <h4 className="mt-3 text-lg font-bold leading-snug">{q.q}</h4>
            <div className="mt-3 grid gap-2">
              {q.options.map((opt, i)=> (
                <button key={i} onClick={()=>answer(i)} className="text-left px-4 py-3 rounded-xl border bg-slate-50 dark:bg-slate-800 border-slate-200 dark:border-slate-700 hover:bg-slate-100 dark:hover:bg-slate-700">
                  <span className="font-medium mr-1">{String.fromCharCode(65+i)}.</span> {opt}
                </button>
              ))}
            </div>
            <div className="mt-3 text-xs text-slate-500">* El orden de las opciones se baraja en cada pregunta.</div>
          </div>
        </div>
      );
    };

    const Feedback = ({correct,onNext})=> (
      <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50">
        <div className={(correct? 'bg-emerald-50 dark:bg-emerald-900/40 border-emerald-300 dark:border-emerald-700 text-emerald-800 dark:text-emerald-200':'bg-rose-50 dark:bg-rose-900/40 border-rose-300 dark:border-rose-700 text-rose-800 dark:text-rose-200')+" w-[min(560px,92vw)] p-4 rounded-2xl border shadow-xl text-center"}>
          <div className="text-xl font-extrabold">{correct? '¬°Correcto!': 'No es correcto'}</div>
          <button onClick={onNext} className="mt-3 px-4 py-2 rounded-2xl bg-slate-900 dark:bg-white text-white dark:text-slate-900 font-semibold">Continuar</button>
        </div>
      </div>
    );

    const Win = ({name})=> (
      <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-50">
        <div className="w-[min(560px,92vw)] p-6 rounded-2xl border bg-white dark:bg-slate-900 border-slate-200 dark:border-slate-700 text-center">
          <div className="text-3xl font-extrabold">üèÜ ¬°{name} consigue todos los quesitos!</div>
          <div className="mt-2 text-slate-600 dark:text-slate-300">Pulsa "Nueva partida" para jugar otra vez.</div>
        </div>
      </div>
    );

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App/>);
  </script>
</body>
</html>
